<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" href="../../BJOC-NL-logo.png" type="image/png">
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="../../js+css/llab/loader.js"></script>
    <script type="text/javascript" src="../../js+css/gifffer.min.js"></script>
    <script type="text/javascript">
        window.onload = function () {
            Gifffer();
            Inhoudsopgave();
        }
    </script>
    <link rel="stylesheet" type="text/css" href="../../js+css/css/bjc-gifffer.css">
    <title>Hoofdstuk 6 Les 1: De Hiërarchie van Computer-abstractie, Pagina 6</title>
</head>

<body>
    <div class="full">
        <h2>Het Digitale Domein: Architectuur</h2>

        <div class="learn"><strong>Op deze pagina</strong>, gaan we in plaats avn naar software naar hardware kijken.
            Het eerste onderwerp is
            <em>architectuur,</em> wat praktisch is hoe de software de hardware ziet.</div>

        <p> De software in een computer is nutteloos zonder de <em>hardware:</em> de daadwerkelijke circuits in de
            computer. Net zoals er lagen van abstractie zijn voor software denken hardware-designers ook in lagen van
            abstractie.
        </p>
        <img class="imageRight noshadow" src="/bjc-r/img/6-computers/hardware-abstraction-mini.png"
            alt="Geen Afbeelding" />
        <p>Iedereen heeft het over computers die alle gegevens vertegenwoordigen met slechts twee waarden, 0 en 1. Maar
            dat is niet echt hoe elektronische circuits werken. Computerontwerpers kunnen doen <em> alsof </em>
            circuits uit (0) of aan (1) staan vanwege <strong> digitale abstractie </strong>, de belangrijkste
            abstractie in hardware. Boven dat abstractieniveau zijn er vier gedetailleerdere niveaus, het
            <strong> digitale domein </strong> genoemd. Onder de digitale abstractie werken ontwerpers in het
            <strong> analoge domein </strong>, waarin een draad in een circuit elke spanningswaarde kan hebben, niet
            slechts twee waarden. </p>
        <p> Op de volgende vier pagina's, zullen we vier lagen van het digitale domein verkennen. </p>

        Everyone talks about computers representing all data using only two values, 0 and 1. But that's not really
        how electronic circuits work. Computer designers can work <em>as if</em> circuits were either off (0) or on
        (1) because of the <strong>digital abstraction</strong>, the most important abstraction in hardware. Above
        that level of abstraction, there are four more detailed levels, called the <strong>digital domain</strong>.
        Below the digital abstraction, designers work in the <strong>analog domain</strong>, in which a wire in a
        circuit can have any voltage value, not just two values.</p>
        <p>On the next four pages, we'll explore four levels of the digital domain.</p>

        <div class="endnote">
            <h3>De Stored program-computer (Computer met opgeslagen programma)</h3>
            <p>Zoals je zal zien in Les 3 zijn er al duizenden jaren machines die berekeningen uitvoeren. Maar de
                moderne, <em>programmeerbare</em> computer komt voort uit het werk van Charles Babbage in de vroege
                jaren van 1800.
            </p>
            <p> Babbage was vooral een wiskundige maar hij heeft veel bijgedragen aan onder andere astronomie en
                economie. Babbage leefde ongeveer 150 jaar geleden van 1791-1871. Dat elektriciteit als een bron van
                energie kon worden gebruikt was nog onbekend. De stoommachine werd populair rond de tijd dat hij was
                geboren. De meeste precieze machines uit zijn tijd waren uurwerken.

                Babbage was mainly a mathematician, but he contributed to fields as varied as astronomy and economics.
                Babbage lived about 150 years ago from 1791-1871. Electricity as a source of energy was unknown. The
                steam engine came into widespread use around the time he was born. The most precise machinery of his
                time was clockwork—gears.</p>

            <h4><strong>De Difference Engine</strong></h4>
            <p>Babbage's eerste computer was de Difference Engine (Verschilmotor).Hij gebruikten tandwielen om een
                ingewikkelde machine te ontwerpen die tabellen met getallen kon berekenen en printen (bijvoorbeld
                tabellen van logaritme functies). Maar deze tandwielen moesten heel precies zijn en ieder tandwiel moest
                met de hand gemaakt worden. Het project werd zo duur dat de overheid de financiering stop zetten en
                Babbage maakte het project nooit af.
            </p>
            <table class="indent">
                <tr>
                    <td>
                        <img src="/bjc-r/img/6-computers/babbage-difference-engine.jpg" height="200px"
                            alt="Geen Afbeelding" /><br />
                        <small>De Difference Engine in het London Science Museum</small><br />
                        <small><small>
                                Afbeelding van Wikimedia-gebruiker geni. Copyright 2008. Licentie: GFDL, CC BY-SA.
                            </small></small>
                    </td>
                    <td>
                        <img src="/bjc-r/img/6-computers/closeup-difference-eng.jpg" height="200px"
                            alt="Geen Afbeelding" /><br />
                        <small>Een close-up die de tandwielen duidelijker laat zien</small><br />
                        <small><small>
                                Afbeelding van Carsten Ullrich. Copyright 2005. Licentie: CC-BY-SA-2.5.
                            </small></small>
                    </td>
                </tr>
            </table>

            <p>
                <a href="#hint-difference" data-toggle="collapse">
                    Leer meer over de geschiedenis van de Difference Engine.
                </a>
                <div id="hint-difference" class="collapse">

                    <p> In de tijd van Babbage werden dergelijke numerieke tabellen met de hand berekend door menselijke
                        wiskundigen, en ze werden met de hand gezet om te worden afgedrukt. Zowel de berekening als het
                        kopiëren naar print waren foutgevoelig, en nauwkeurige tabellen waren nodig voor doeleinden
                        variërend van engineering tot navigatie. </p>
                    <p> Babbage bouwde eerst een kleine Difference Engine in 1822. Deze eerste poging bewees dat een
                        Difference Engine mogelijk was, maar het had niet de precisie (aantal cijfers voor elk getal) om
                        praktisch te zijn. In 1823 financierde de Britse overheid Babbage om een ​​grotere versie te
                        bouwen. Helaas konden metaalsmeden in zijn tijd niet erg precieze tandwielen in grote
                        hoeveelheden produceren; elk moest handgemaakt zijn. Dus had hij hij tien keer zijn
                        goedgekeurde budget besteed tegen de tijd dat de overheid het project in 1842 stopzette.</p>
                    <p> In 1991 voltooide het London Science Museum een Difference Engine volgens het oorspronkelijke
                        ontwerp van Babbage met behulp van tandwielen gemaakt door moderne processen, maar op het niveau
                        van precisie dat beschikbaar was voor Babbage. Dit bewees dat Babbage in principe een werkende
                        machine had kunnen voltooien met voldoende tijd en geld. </p>
                </div>
            </p>

            <h4><strong>De Analytical Engine</strong></h4>
            <p> De Difference Engine kan worden gebruikt om veel verschillende functies te berekenen door de
                startpositie van verschillende versnellingen handmatig in te stellen. Maar het had
                <strong> slechts één algoritme </strong>: het algoritme ingebouwd in het hardware-ontwerp. In 1833 begon
                Babbage te werken aan de Analytical Engine, die gebaseerd was op het algemene idee van de Difference
                Engine maar die wel <strong> instructies uit kon voeren </strong> in een primitieve programmeertaal die
                met ponskaarten werkten. <br />
                <div class="sidenote">
                    <small>Ponskaarten gebruikt om de Analytical Engine te programmeren</small><br />
                    <small><small>Karoly Lorentey. Copyright 2004. Licentie: CC-BY.</small></small>
                </div>
                <img class="indent" src="/bjc-r/img/6-computers/punched-cards-analytical-engine.jpg" height="300px"
                    alt="Geen Afbeelding" />
            </p>

            <p> Tegenwoordig zijn we omringd door programmeerbare computers en het is nu vanzelfsprekend om software
                te hebben. Maar dit was niet altijd zo, vóór Babbage werden alle algoritmen rechtstreeks in hardware
                geïmplementeerd. </p>
            <p> Dus, 150 jaar geleden, maakte Babbage plannen voor wat in wezen een moderne computer is, hoewel hij geen
                elektronica beschikbaar had. Zijn onderliggende idee voor hardware was volledig mechanisch, maar het
                bleek niet mogelijk te zijn om het met de toenmalige technologie te bouwen. We hebben geen
                <em> bruikbare </em> computers gekregen totdat er een onderliggende technologie was die klein,
                goedkoop en snel genoeg was om de software-abstractie te ondersteunen. Je leert snel over deze
                technologie, transistors. </p>
        </div>

        <div class="takeNote">The abstraction of <em>software</em> (a program stored in the computer's memory) is what
            makes a computer usable for more than one purpose.</div>

        <div class="endnote">
            <p>
                <a href="#hint-analytical" data-toggle="collapse"> Leer meer over de Analytical Engine.</a>
                <div id="hint-analytical" class="collapse">
                    <p>De Analytical Engine, had net als moderne computers, een rekenkundige processor (genaamd de
                        "molen") en een apart geheugen (de "winkel") die 1000 getallen kon bijhouden, ieder tot en met
                        40
                        cijfers. De molen voerde rekenkundige handelingen uit in decimalen (met cijfers 0-9 verdeeld
                        over ieder tandwiel); het gebruik van "enen en nullen" kwam pas later.
                    </p>
                    <p>De programmeertaal die gebruikt werd in de Analytical Engine had ook condities en lussen, wat
                        alles is dat je nodig hebt om een algoritme te maken. (Het kon lussen maken omdat het voorwaarts
                        en achterwaarts door de ponskaarten kon gaan.)
                    </p>
                    <p>Helaas kon Babbage maar een klein deel van de Analytical Engine bouwen, die nog meer metaalwerk
                        nodig had dan de Difference Engine. Zijn aantekeningen over het ontwerp waren niet volledig en
                        dus heeft niemand ooit een werkend model gebouwd, alhoewel er simulaties zijn op het internet
                        (zie het Ga Een Stapje Verder-probleem hieronder). Jammer genoeg was Babbage werk niet bekend in
                        de vroege dagen van elektronische computers en veel mensen hebben zijn ideeën heruitgevonden.
                    </p>
                </div>
            </p>
            <p>
                <a href="#hint-ada" data-toggle="collapse">Leer over Ada, Gravin Lovelace's uitvinding van symbolisch
                    programmeren.
                </a>
                <div id="hint-ada" class="collapse">
                    <p> Alhoewel zijn ontwerp zeer veelzijdig was, was Babbage vooral geïnteresseerd
                        in het afdrukken van getallentabellen. Het was zijn medewerker Augusta Ada King-Noel, gravin van
                        Lovelace, die voor het eerst inzag dat de nummers in de computer van Babbage niet alleen als
                        hoeveelheden konden worden gebruikt, maar ook als weergave van muzieknoten, letters,
                        enzovoort. </p>
                    <img class="indent" height="300px" src="/bjc-r/img/6-computers/ada-lovelace.jpg"
                        alt="Geen Afbeelding" />
                    <div class="sidenote">
                        <small>Afbeelding van Alfred Edward Chalon, Science &amp; Society Picture Library, Publiek
                            Domein, via
                            Wikimedia.</small>
                    </div>

                    <p> Veel van wat we vandaag weten over het ontwerp van Babbage komt uit de uitgebreide aantekeningen
                        van Ada Lovelace over zijn ontwerp. Haar aantekeningen omvatten het eerste <em> gepubliceerde
                        </em> programma voor de Analytical Engine, en daarom wordt ze algemeen beschouwd als "de eerste
                        programmeur", hoewel het bijna zeker is dat Babbage zelf verschillende voorbeeldprogramma's
                        heeft geschreven tijdens het ontwerpen van de machine. </p>
                    <p> Of ze nu echt de eerste programmeur was of niet, historici zijn het erover eens dat ze iets
                        belangrijkers heeft gedaan: ze heeft het idee van <em> symbolische </em> berekening
                        (inclusief tekst, afbeeldingen, muziek, etc.) naar numerieke berekening uitgevonden. Dit
                        inzicht maakte de weg vrij voor alle manieren waarop computers tegenwoordig worden gebruikt,
                        van Netflix tot stem-interactieve programma's zoals Siri en Alexa. </p>
                </div>
            </p>
        </div>

        <h3>Wat is een Architectuur?</h3>
        <p>De Analytical Engine (boven beschreven) was de eerste programmeerbare computerarchitectuur.
            De processor in de computer die je nu gebruikt begrijpt maar één taal: zijn eigen <em>machinetaal</em>, niet
            Java, C of Snap<em>!</em>, of iets anders. Programma's die geschreven zijn in die andere talen moeten eerst
            vertaald worden naar machinetaal. </p>
        <p> Het belangrijkste van de architectuur is de machinetaal. De set instructies van zeer laag niveau die de
            hardware begrijpt. Deze taal is een soort contract tussen de hardware en de software: De hardware belooft de
            instructies te begrijpen en de software compileert programma's van mens-vriendelijke taal naar deze
            instructies.</p>

        <div class="vocabFullWidth">
            <p><strong>Machinetaal</strong> is programmeertaal op het laagste niveau; het wordt direct begrepen door de
                hardware.
            </p>
            <p><strong>Architectuur</strong> is een abstractie, een specificate van de machinetaal. Het zegt ook hoe de
                processor verbonden is met het geheugen. Het specificeert niets van de circuits; dezelfde architectuur
                kan op meerdere manieren worden gebouwd qua circuits.

        </div>
        <p> Een belangrijk onderdeel van een architectuur is het aantal draden dat de processor en het geheugen met
            elkaar verbindt. Dit wordt de <em> breedte </em> van de architectuur genoemd, gemeten in <em> bits </em>
            (aantal draden). Een bredere computer kan meer gegevens in één instructie verwerken. </p>

        <div class="endnote">
            <a href="#hint-machine-language" data-toggle="collapse">Hoe ziet machinetaal eruit?</a>
            <div id="hint-machine-language" class="collapse">
                <p>
                    Bekijk de Snap<em>!</em>-instructie
                    <img class="inline nopad" src="/bjc-r/img/6-computers/set-c-to-a+b.png" alt="Geen Afbeelding" />.
                    In een taal op laag niveau zoals C of Java zou het zelfde idee geschreven als: <br />
                    <pre>c = a+b;</pre>
                    Dat simpele commando zou vertaald kunnen worden in <em>zes</em> machinetaalinstructies (een beetje
                    versimpeld): <br />
                    <pre>
movq    _c, %rcx
movq    _b, %rdx
movq    _a, %rsi
movl    (%rsi), %edi
addl    (%rdx), %edi
movl    %edi, (%rcx)</pre>
                    Deze notatie, <em>assembly-taal</em> genaamd, is een regel voor regel-equivalent aan de
                    daadwerkelijke numerieke instructiecode, maar het is iets meer leesbaar.
                </p>
                <a href="#hint-assembly" data-toggle="collapse">Wat betekent de code?</a>
                <div id="hint-assembly" class="collapse">
                    <p>De eerste drie instructies laden de <em>adressen</em> van de drie variabelen in de registers in
                        de processor. De namen met een percentage-teken zoals <code>%rcx</code> verwijzen naar
                        specifieke registers.<code>Movq</code> is de naam van een machinetaalinstructie. (Het is een
                        afkorting voor "move quote", wat betekent dat we een constante waarde in een register plaatsen.
                        Merk op dat <var>a</var> een variabele is, maar <em>het adres van</em> <var>a</var> is een
                        constante waarde, omdat de variabele niet wordt verplaatst in het geheugen.)</p>
                    <p> De volgende instructie, <code>movl</code> ("move long"), zegt dat een woord van de ene plek naar
                        de andere moet worden verplaatst. Als een registernaam tussen haakjes staat zoals
                        <code>(%rsi</code> dan betekent dat dat we locatie in het geheugen gebruiken van wie het adres
                        in dat register staat. Omdat de derde <code>movq</code> het adres van <var>a</var> in register
                        <code>%rsi</code> heeft geplaatst zegt de eerste <code>movl</code> dat de variabele <var>a</var>
                        van het geheugen in de processorregister moet worden geplaatst.
                        De instructie <code>addl</code> zegt dat <var>b</var> moet worden toegevoegd aan hetzelfde
                        register. Aan het einde wordt de waarde in register <code>%edi</code> in de geheugen locatie
                        geplaatst van variabele <var>c</var>.
                    </p>
                </div>
                <p>Je wil niet moeten programmeren in deze taal! En dat <em> hoeft ook niet</em> ; moderne architecturen
                    zijn ontworpen voor compilers, niet voor machinetaalprogrammeurs.
                </p>
            </div>
        </div>
        <div class="endnote">
            Leer over:
            <ul>
                <li>
                    <a href="#hint-architecture" data-toggle="collapse">PC/Mac-architectuur</a>
                    <div id="hint-architecture" class="collapse">

                        <p> De meeste computerprocessors (het onderdeel dat instructies uitvoert) op desktop- of
                            laptopcomputers gebruiken een architectuur genaamd "x86" die is ontworpen door Intel, een
                            chipfabrikant. De eerste processor die die architectuur gebruikte, heette de 8086,
                            uitgebracht in 1978. (De reden voor de naam x86 is dat de eerste paar verbeterde versies
                            80286, 80486, enz. Werden genoemd.) De originele 8086 was een 16-bitarchitectuur; sindsdien
                            zijn 32-bit (sinds 1985) en 64-bit (sinds 2003) versies ontwikkeld. Zelfs met alle
                            verfijningen van de architectuur zijn de nieuwe x86-processors bijna altijd
                            <em> backwards compatible </em> wat betekent dat de versies van vandaag nog steeds
                            programma's uitvoeren die zijn geschreven voor de originele 8086. </p>
                        <p> Waarom is de x86-architectuur de wereld gaan regeren? Het korte antwoord is dat IBM het in
                            hun oorspronkelijke pc gebruikte en dat alle latere pc-fabrikanten hun voorbeeld volgden
                            zodat ze IBM-compatibele software ongewijzigd konden uitvoeren. Maar waarom koos IBM voor de
                            x86? Er waren aantoonbaar beter concurrerende architecturen beschikbaar, zoals de Motorola
                            68000 en de eigen 801 van IBM. De pc-ontwerpers hadden ruzie over wat ze moesten gebruiken,
                            maar uiteindelijk maakte het verschil de lange geschiedenis van IBM van het werken met
                            Intel. </p>
                        <p> De Apple Macintosh gebruikte oorspronkelijk de Motorola 68000-architectuur en in 1994
                            ontwierp Apple zijn eigen PowerPC-architectuur in een gezamenlijk project met IBM en
                            Motorola, maar in 2006 schakelden ze ook over op de x86, omdat Intel nieuwere, snellere
                            versies van de x86 blijft produceren, vaker dan andere bedrijven kunnen bijhouden. </p>
                    </div>
                </li>
                <li>
                    <a href="#hint-architecture-phone" data-toggle="collapse">Smartphone-architectuur</a>
                    <div id="hint-architecture-phone" class="collapse">
                        <p> Alles van smartphone-architectuur wordt bepaald door de kleine ruimte in de behuizing. De
                            hoogte en breedte van de telefoon worden beperkt door de grootte van de zakken in de kleding
                            van
                            mensen. <em> (Houd je telefoon niet in je achterbroekzak. Dat is echt slecht, zowel voor de
                                telefoon als voor je rug.) </em> De voorkant-naar-achterkantdiepte van een telefoon kan
                            veel groter zijn dan nu vaak het geval is , maar om de een of andere reden concurreren
                            telefoonfabrikanten op de dunheid van hun telefoons, waardoor ontwerpers nog minder ruimte
                            hebben. </p>
                        <p> Als gevolg hiervan zijn veel componenten die gescheiden zouden zijn van de processorchip in
                            een computer, onderdeel van de processorchip in een telefoon. Deze componenten
                            kunnen bestaan uit een mobiele modem, een WiFi-modem, een grafische processor
                            (een processor die is gespecialiseerd in parallel rekenen met lijsten van
                            nummers), geheugen, een GPS-ontvanger om de fysieke locatie van je telefoon te vinden,
                            circuits om de stroom en batterij te beheren en meer. Tegenwoordig bevat de chip
                            waarschijnlijk twee, vier of zelfs acht kopieën van de werkelijke CPU om multicore-systemen
                            te maken. Deze verzameling componenten wordt een <em> systeem op een chip, </em> of SoC
                            genoemd. </p>
                        <p> Intel heeft een x86-gebaseerde (dat wil zeggen dezelfde architectuur die op pc's wordt
                            gebruikt) low-power SoC gemaakt genaamd de Atom, die werd gebruikt in een paar
                            Motorola-telefoons en andere telefoons die zijn gemaakt door bedrijven waar je nog nooit van
                            hebt
                            gehoord. Het is gemaakt om Android-, Linux- en Windows-telefoons te ondersteunen. </p>
                        <p> Maar de overgrote meerderheid van de telefoons gebruikt de ARM-architectuur, die (in
                            tegenstelling tot de x86) vanaf het begin is ontworpen als een energiezuinige architectuur.
                            Het acroniem staat voor Advanced RISC Machine. Het is beschikbaar in 32-bit- en
                            64-bitconfiguraties. </p>

                        <div class="endnote">
                            <a href="#hint-risc" data-toggle="collapse">What is een RISC?</a>
                            <div id="hint-risc" class="collapse">
                                <p> De naam staat voor Reduced Instruction Set Computer
                                    (Verkleinde-Instructiesetcomputer), in tegenstelling tot de CISC-architectuur
                                    (Complex Instruction Set Computer dus de Complexe-Instructiesetcomputer), inclusief
                                    de x86. De <em> instructieset </em> van een architectuur is, zoals je uit de naam
                                    kunt raden, de set instructies die de processor begrijpt. Een RISC heeft minder
                                    instructies dan een CISC, maar is ook op andere manieren eenvoudiger. Een CISC heeft
                                    bijvoorbeeld doorgaans meer <em> adresseermodi </em> in de instructies. In de
                                    x86-architectuur kan de instructie <code> add </code> twee processorregisters
                                    toevoegen, of een register en een waarde uit het geheugen van de computer, of een
                                    constante waarde die in de instructie zelf is ingebouwd. De instructie <code> add
                                    </code> van een RISC-architectuur weet gewoon hoe hij twee registers moet toevoegen
                                    (misschien moet het resultaat in een derde register geplaatst worden), en er zijn
                                    afzonderlijke <code> load </code> en <code> store </code> instructies die waarden
                                    uit het geheugen kopiëren in een register of andersom. Ook hebben in een
                                    RISC-architectuur alle instructies dezelfde lengte (bijvoorbeeld 32 bits), terwijl
                                    in een CISC-architectuur de instructielengtes kunnen variëren. Deze verschillen zijn
                                    belangrijk omdat een RISC de volgende instructie kan laden voordat deze klaar is met
                                    de vorige instructie en een RISC nooit meer dan één geheugengegevensreferentie per
                                    instructie heeft. </p>
                                <p> Dus waarom gebruiken ze geen RISC architectuur in pc's? Ooit gebruikte Apple een
                                    RISC-processor genaamd de PowerPC in zijn Macintosh-computers, maar de overgrote
                                    meerderheid van de verkochte computers zijn pc's, geen Mac's, en als gevolg daarvan
                                    besteedt Intel enorme bedragen aan het bouwen van snellere en snellere circuits die
                                    de x86-architectuur implementeren. De moraal gaat over de interactie tussen
                                    verschillende abstractieniveaus: een betere architectuur kan worden overwonnen door
                                    een beter circuitontwerp of betere technologie om componenten in een geïntegreerd
                                    circuit te proppen. </p>
                            </div>
                        </div>
                        <p> Het bedrijf dat de ARM heeft ontworpen, genaamd ARM Holdings, bouwt eigenlijk geen
                            processors. Ze verlenen een licentie voor het architectuurontwerp of circuitontwerp aan
                            andere bedrijven die ARM-processors integreren in SoC's. Grote bedrijven
                            die op ARM gebaseerde processorchips bouwen, zijn Apple, Broadcom, Qualcomm en Samsung.
                            Fabrikanten van smartphones kopen chips van een van deze bedrijven. </p>
                    </div>
                </li>
                <li>
                    <a href="#hint-architecture-iot" data-toggle="collapse">Ingebouwde Architectuur en het "Internet of
                        Things"</a>
                    <div id="hint-architecture-iot" class="collapse">
                        <p> Je kunt thermostaten kopen met computers erin, koelkasten met computers erin, pluizig
                            dierenspeelgoed met computers erin - meer en meer dingen, naarmate de tijd verstrijkt.
                            Moderne auto's bevatten <em> meerdere </em> computers, grotendeels om veiligheidsredenen; je
                            zou niet willen dat de remmen falen omdat de dvd-speler een probleem heeft. Het doel, zoals
                            beschreven door onderzoekers in de informatica, is "smart dust" (slim stof), wat betekent
                            dat veel
                            computers onopgemerkt door een gebouw kunnen zweven. Wat heb je aan een onopgemerkte
                            computer? Dit is een klassieke technologie voor dubbel gebruik. Het nuttige gebruik waar
                            iedereen het over heeft, is noodhulp bij rampen; het zou een grote hulp zijn voor de
                            brandweer om van buitenaf te weten in welke ruimtes van een gebouw mensen aanwezig zijn.
                            Maar een ander gebruik voor deze technologie zou spioneren zijn. </p>
                        <p>You can buy thermostats with computers in them, refrigerators with computers in them, fuzzy
                            animal toys with computers in them—more and more things, as time goes on. Modern automobiles
                            have <em>several</em> computers in them, largely for safety reasons; you wouldn't want the
                            brakes to fail because the DVD player has a problem. The goal, as described by researchers
                            in computing, is "smart dust," meaning that lots of computers could be floating around a
                            building unnoticed. What good is an unnoticed computer? This is a classic dual use
                            technology. The beneficial use everyone talks about is emergency response to disasters; it
                            would be a great help to the fire department to know, from the outside, which rooms of a
                            building have people in them. But another use for this technology would be spying.</p>
                        <p class="indent">
                            <img src="/bjc-r/img/6-computers/freescale_scmimx6d-sm.jpg" alt="Geen Afbeelding"><br />
                            <small><small>NXP Freescale SCM-i.MX6D chip</small></small>
                        </p>
                        <p> Voor ingebouwde computers zijn de belangrijkste ontwerpcriteria kleine afmetingen en een
                            laag stroomverbruik. De chip in de bovenstaande afbeelding is gebaseerd op de
                            ARM-architectuur,
                            zoals de meeste mobiele telefoons. Dat is eigenlijk een <em> grote </em> chip voor
                            ingebouwde
                            systemen; de Kinetis KL02 MCU (microcontroller-eenheid) past in een vierkant van 2
                            millimeter. Dat is nog steeds te groot om als stof in de lucht te
                            zweven, maar stel je het voor op de muur in een kleverige container. </p>
                        <p> Op een dag zal het spioneren nog effectiever zijn (samen met, hopelijk, behandeling voor
                            hersenziekten): <a
                                href="https://www.engadget.com/2017/05/17/arm-targets-your-brain-with-new-implantable-chips/"
                                target="_blank">ARM richt zich op je brein met nieuwe implanteerbare chips</a>
                            (Engadget, 5/17/2017).</p>
                        <p> Intel maakte in 2015 een x86-compatibele chip ter grootte van een knop, maar kondigde in
                            2017 aan dat dit zo zou zijn stopgezet, waardoor alleen ARM- en PowerPC-gebaseerde
                            processors op de markt blijven concurreren. </p>
                    </div>
                </li>
                <li>
                    <a href="#hint-architecture-hobby" data-toggle="collapse">Hobby-computerarchitectuur</a>
                    <div id="hint-architecture-hobby" class="collapse">

                        <p> In zekere zin kan <em> elke </em> architectuur een hobby-architectuur zijn. Zelfs in
                            de tijd van computers van een miljoen dollar waren er softwarehobbyisten die manieren vonden
                            om naar computerlokalen op de universiteit te gaan, vaak door zichzelf daar nuttig te maken.
                            Tegenwoordig zijn er veel meer krachtige computers die goedkoop genoeg zijn dat hobbyisten
                            ze uit elkaar willen halen. Maar er zijn enkele computerarchitecturen <em> specifiek </em>
                            bedoeld voor hobbyisten. </p>
                        <img class="imageRight" src="/bjc-r/img/6-computers/arduino.jpg" alt="Geen Afbeelding" />
                        <p> Veruit de meest populaire computer specifiek voor hobbyisten is de Arduino. Het is een
                            printplaat, niet alleen een processor. Rond de randen van het bord zitten connectoren. Aan
                            de korte rand links in de afbeelding bevindt zich de stroomingang, die kan worden
                            aangesloten op een voeding die is aangesloten op een stopcontact of op een batterij voor een
                            mobiel
                            apparaat zoals een robot, en een USB-aansluiting die voornamelijk wordt gebruikt om
                            programma's te downloaden van een desktop of laptop computer. Aan de lange randen bevinden
                            zich connectoren voor afzonderlijke draden die zijn aangesloten op externe sensoren (voor
                            licht, warmte, bij een muur zijn, een ander object aanraken, enz.) Of actuatoren
                            (stappenmotoren, lichten, zoemers, enz.). </p>
                        <p> Een belangrijk aspect van het Arduino-ontwerp is dat het <em> vrij </em> is ("vrij als
                            in vrijheid"). Iedereen kan de Arduino maken en zelfs verkopen. Dit is goed
                            omdat het de prijs laag houdt (het standaard Arduino Uno-bord kost $ 22) en stimuleert
                            innovatie, maar het betekent ook dat er incompatibele Arduino-achtige boards kunnen zijn.
                            (De naam "Arduino" is een handelsmerk dat alleen kan worden gebruikt met een licentie van
                            Arduino AG.) </p>
                        <p> De processor in de meeste Arduino-modellen is een 8-bit RISC-systeem met geheugen in de
                            chip, genaamd AVR, van een bedrijf genaamd Atmel. Het werd ontworpen door twee
                            (toenmalige) studenten in Noorwegen, Alf-Egil Bogen en Vegard Wollan genaamd. Hoewel
                            officieel "AVR" nergens voor staat, wordt algemeen aangenomen dat het afkomstig is van " Alf
                            en Vegard hun RISC". Er zijn verschillende versies van de AVR-processor, met verschillende
                            snelheden, geheugencapaciteiten en natuurlijk prijzen; er zijn verschillende
                            Arduino-modellen die de verschillende processors gebruiken. </p>
                        <p> In tegenstelling tot de meeste ("von Neumann-architectuur") computers, scheidt de AVR
                            ("Harvard-architectuur") programmageheugen van gegevensgeheugen. (Het heeft eigenlijk <em>
                                drie </em> soorten geheugen, een voor het actieve programma, een voor gegevens op korte
                            termijn en een voor gegevens op lange termijn.) De Analytical Engine van Babbage is ook
                            ontworpen met een programmageheugen dat los staat van zijn data geheugen. </p>

                        <div class="endnote">
                            <a href="#hint-Harvard" data-toggle="collapse">
                                Waarom zou je meer dan één soort geheugen willen?
                            </a>
                            <div id="hint-Harvard" class="collapse">
                                <p> Er zijn eigenlijk twee verschillende ontwerpproblemen in deze architectuur. Een
                                    daarvan is helemaal in het analoge domein en heeft te maken met het soort fysieke
                                    circuits
                                    dat wordt gebruikt. Er zijn <em> veel </em> geheugentechnologieën, variërend in
                                    kosten, snelheid en <em> vluchtigheid: </em> vluchtig geheugen verliest de
                                    informatie die erin is opgeslagen wanneer het apparaat wordt uitgeschakeld, terwijl
                                    niet-vluchtig geheugen de informatie behoudt. Dit is hoe geheugen wordt gebruikt in
                                    de AVR-chips: <ul>
                                        <li> <strong> EEPROM </strong> (512 Bytes – 4kBytes) is niet-vluchtig en wordt
                                            gebruikt voor gegevens op zeer lange termijn, zoals een bestand op een
                                            computer schijf, behalve dat er slechts een kleine hoeveelheid beschikbaar
                                            is. Programma's op de Arduino moeten expliciet vragen om dit geheugen te
                                            gebruiken, met een EEPROM-bibliotheek. <ul>
                                                <li> De naam staat voor Electrically Erasable Programmable Read-Only
                                                    Memory (Elektrisch-Verwijderbaar Programmeerbaar
                                                    Alleen-te-Lezen-Geheugen), wat klinkt als een contradictio in
                                                    terminis. In de
                                                    begindagen van op transistor gebaseerde computers waren er twee
                                                    soorten geheugen, vluchtig (Random Access Memory of RAM) en
                                                    niet-vluchtig (Read-Only Memory of ROM). De waarden die in een
                                                    vroege ROM waren opgeslagen, moesten door de fabrikant van de
                                                    geheugenchip worden ingebouwd, dus het was duur om een ​​nieuwe te
                                                    laten maken. Toen kwam Programmable Read-Only Memory (PROM), dat
                                                    alleen kon worden gelezen als het eenmaal geïnstalleerd was op een
                                                    computer, maar het kon
                                                    worden geprogrammeerd, eenmalig, met behulp van een machine die
                                                    slechts enigszins duur was. Toen kwam EPROM, Erasable PROM, dat in
                                                    zijn geheel kon worden gewist door er een helder ultraviolet licht
                                                    op te laten schijnen en vervolgens opnieuw te programmeren als een
                                                    PROM. Eindelijk was er Electrically Erasable PROM, dat tijdens het
                                                    installeren op een computer kon worden gewist, dus in wezen gelijk
                                                    aan RAM, behalve dat het wissen veel langzamer is dan een iets in
                                                    RAM herschrijven, dus je gebruikt het alleen voor waarden die niet
                                                    van vaak gewijzigd worden. </li>
                                            </ul>
                                        </li>
                                        <p> There are actually two different design issues at work in this architecture.
                                            One is all the way down in the analog domain, having to do with the kind of
                                            physical circuitry used. There are <em>many</em> memory technologies,
                                            varying in cost, speed, and <em>volatility:</em> volatile memory loses the
                                            information stored in it when the device is powered off, while non-volatile
                                            memory retains the information. Here's how memory is used in the AVR chips:
                                            <ul>
                                                <li> <strong>EEPROM</strong> (512 Bytes–4kBytes) is non-volatile, and is
                                                    used for very long term data, like a file in a computer's disk,
                                                    except that there is only a tiny amount available. Programs on the
                                                    Arduino have to ask explicitly to use this memory, with an EEPROM
                                                    library. <ul>
                                                        <li>The name stands for Electrically Erasable Programmable
                                                            Read-Only Memory, which sounds like a contradiction in
                                                            terms. In the early days of transistor-based computers,
                                                            there were two kinds of memory, volatile (Random Access
                                                            Memory, or RAM) and nonvolatile (Read-Only Memory, or ROM).
                                                            The values stored in an early ROM had to be built in by the
                                                            manufacturer of the memory chip, so it was expensive to have
                                                            a new one made. Then came Programmable Read-Only Memory
                                                            (PROM), which was read-only once installed in a computer,
                                                            but could be programmed, once only, using a machine that was
                                                            only somewhat expensive. Then came EPROM, Erasable PROM,
                                                            which could be erased in its entirety by shining a bright
                                                            ultraviolet light on it, and then reprogrammed like a PROM.
                                                            Finally there was Electrically Erasable PROM, which could be
                                                            erased while installed in a computer, so essentially
                                                            equivalent to RAM, except that the erasing is much slower
                                                            than rewriting a word of RAM, so you use it only for values
                                                            that aren't going to change often.</li>
                                                    </ul>
                                                </li>
                                                <li> <strong>SRAM</strong> (1k–4kBytes): This memory can lose its value
                                                    when the
                                                    machine is turned off; in other words, it's volatile. It is used for
                                                    temporary data, like the script variables in a Snap<em>!</em>
                                                    script. <ul>
                                                        <li>The name stands for Static Random Access Memory. The "Random
                                                            Access"
                                                            part differentiates it from the magnetic tape storage used
                                                            on very
                                                            old computers, in which it took a long time to get from one
                                                            end of
                                                            the tape to another, so it was only practical to write or
                                                            read data
                                                            in sequence. Today all computer memory is random access, and
                                                            the
                                                            name "RAM" really means "writable," as opposed to read-only.
                                                            The
                                                            "Static" part of the name means that, even though the memory
                                                            requires power to retain its value, it <em>doesn't</em>
                                                            require
                                                            periodic refreshing as regular ("Dynamic") computer main
                                                            memory
                                                            does. ("Refreshing" means that every so often, the computer
                                                            has to
                                                            read the value of each word of memory and rewrite the same
                                                            value, or
                                                            else it fades away. This is a good example of computer
                                                            circuitry
                                                            whose job is to maintain the <em>digital abstraction,</em>
                                                            in which
                                                            a value is zero or one, and there's no such thing as
                                                            "fading" or
                                                            "in-between values.") Static RAM is faster but more
                                                            expensive than
                                                            dynamic RAM; that's why DRAM is used for the very large
                                                            (several
                                                            gigabytes) memories of desktop or laptop computers.</li>
                                                    </ul>
                                                </li>
                                                <li> <strong>Flash</strong> memory (16k–256kBytes): This is the main
                                                    memory used
                                                    for programs and data. Flash memory is probably familiar to you
                                                    because it's
                                                    used for the USB sticks that function as portable external file
                                                    storage.
                                                    It's technically a kind of EEPROM, but with a different physical
                                                    implementation that makes it much cheaper (so there can be more of
                                                    it in the
                                                    Arduino), but more complicated to use, requiring special control
                                                    circuitry
                                                    to maintain the digital abstraction. <ul>
                                                        <li>"More complicated" means, for example, that changing a bit
                                                            value
                                                            from 1 to 0 is easy, but changing it from 0 to 1 is a much
                                                            slower
                                                            process that involves erasing a large block of memory to
                                                            <em>all</em> 1 bits and then rewriting the values of the
                                                            bits you
                                                            didn't want to change.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </p>
                                        <p>So, that's why there are physically different kinds of memory in the AVR
                                            chips, but
                                            none of that completely explains the Harvard architecture, in which memory
                                            is
                                            divided into <em>program</em> and <em>data,</em> regardless of how long the
                                            data
                                            must survive. The main reason to have two different memory interface
                                            circuits is
                                            that it allows the processor to read a program instruction and a data value
                                            <em>at
                                                the same time.</em> This can in principle make the processor twice as
                                            fast,
                                            although that much speed gain isn't found in practice.</p>
                                        <p>To understand the benefit of simultaneous instruction and data reading, you
                                            have to
                                            understand that processors are often designed using an idea called
                                            <em>pipelining.</em> The standard metaphor is about doing your laundry, when
                                            you
                                            have more than one load. You wash the first load, while your dryer does
                                            nothing;
                                            then you <em>wash the second load while drying the first load, </em>and so
                                            on until
                                            the last load. Similarly, the processor in a computer includes circuitry to
                                            decode
                                            an instruction, and circuitry to do arithmetic. If the processor does one
                                            thing at a
                                            time, then at any moment either the instruction decoding circuitry or the
                                            arithmetic
                                            circuitry is doing nothing. But if you can read the next instruction at the
                                            same
                                            time as carrying out the previous one, all of the processor is kept busy.
                                        </p>
                                        <p>This was a long explanation, but it's still vastly oversimplified. For one
                                            thing,
                                            it's possible to use pipelining in a von Neumann architecture also. And for
                                            another,
                                            a <em>pure</em> Harvard architecture wouldn't allow a computer to load
                                            programs for
                                            itself to execute. So various compromises are used in practice.</p>
                            </div>
                        </div>
                        <p>Atmel has since introduced a line of ARM-compatible 32-bit processors, and Arduino has boards
                            using that processor but compatible with the layout of the connectors on the edges.</p>
                        <p>One thing that has contributed to the popularity of the Arduino with hobbyists is the
                            availability of <em>shields,</em> which are auxiliary circuit boards that plug into the side
                            edge connectors and have the same connectors on their top side. Shields add features to the
                            system. Examples are motor control shields, Bluetooth shields for communicating with cell
                            phones, RFID shields to read those product tags you find inside the packaging of many
                            products, and so on. Both the Arduino company and others sell shields.</p>
                        <div class="sidenote">
                            <small>Stack of Arduino shields</small><br />
                            <small><small>Image by Wikimedia user Marlon J. Manrique, CC-BY-SA 2.0.</small></small>
                        </div>
                        <img class="indent" src="/bjc-r/img/6-computers/arduino-shields.jpg" width="250px"
                            alt="Geen Afbeelding" />
                        <p>A completely different hobbyist architecture is the <em>Raspberry Pi.</em> It was designed to
                            be used like a desktop or laptop computer, but with more access to its electronics. It uses
                            an ARM-compatible processor, like most cell phones, but instead of running phone operating
                            system software such as Android, it runs "real" computer besturingssystemen. It ships with
                            Linux, but people have run Windows on it.</p>
                        <p>The main thing that makes it exciting is that it's inexpensive: different models range in
                            price from $5 to $35. That price includes just the circuit board, as in the picture, without
                            a keyboard, display, mouse, power adapter, or a case. The main expense in kit computers is
                            the display, so the Pi is designed to plug into your TV. You can buy kits that include a
                            minimal case, a keyboard, and other important add-ons for around $20. You can also buy fancy
                            cases to make it look like any other computer, with a display, for hundreds of dollars. </p>
                        <p>Because the Pi is intended for educational use, it comes with software, some of which is free
                            for anyone, but some of which generally costs money for non-Pi computers. One important
                            example is Mathematica, which costs over $200 for students (their cheapest price), but is
                            included free on the Pi.</p>
                        <p>Like the Arduino, the Pi supports add-on circuit boards with things like sensors and wireless
                            communication modules.</p>
                        <div class="sidenote">
                            <small>Raspberry Pi board</small><br />
                            <small><small>Image by Evan Amos, via Wikimedia, public domain</small></small>
                        </div>
                        <img class="indent" src="/bjc-r/img/6-computers/raspberry-pi.jpg" width="250px"
                            alt="Geen Afbeelding" />
                    </div>
                </li>
            </ul>
        </div>
        <div class="endnote">
            <a href="#hint-architecture-general" data-toggle="collapse">Learn more about computer architecture in
                general.</a>
            <div id="hint-architecture-general" class="collapse">

                <h4>The memory hierarchy</h4>
                <p>For a given cost of circuit hardware, <strong>the bigger the memory, the slower it works.</strong>
                    For this reason, computers don't just have one big chunk of memory. There will be a small number of
                    <em>registers</em> inside the processor itself, usually between 8 and 16 of them. The "size" (number
                    of bits) of a data register is equal to the width of the architecture.</p>
                <p>The computer's main memory, these days, is measured in GB (gigabytes, or billions of bytes). A memory
                    of that size can't be fast enough to keep up with a modern processor. Luckily, computer programs
                    generally have <em>locality of reference,</em> which means that if the program has just made use of
                    a particular memory location, it's probably going to use a nearby location next. So a complete
                    program may be very big, but over the course of a second or so only a small part of it will be
                    needed. Therefore, modern computers are designed with one or more <em>cache</em> memories—much
                    smaller and therefore faster—between the processor and the main memory. The processor makes sure
                    that the most recently used memory is copied into the cache. </p>
                <p>One recent 64-bit x86 processor has a first level (L1) cache of 64KB (thousands of bytes) inside the
                    processor chip, a larger but slower L2 cache of 256 KB, also inside the processor, and an L3 cache
                    of up to 2 MB (megabytes, millions of bytes) outside the processor. Each level of cache has a copy
                    of the most recently used parts of the next level outward: the L1 cache copies part of the L2 cache,
                    which copies part of the L3 cache, which copies part of the main memory. Data in the L1 cache can be
                    accessed by the processor about as fast as its internal registers, and each level outward is a
                    little slower. Hardware in the processor handles all this complexity, so that programmers can write
                    programs as if the processor were directly connected to the main memory.</p>
                <h4>Second sourcing</h4>
                <p>Intel licenses other chip manufacturers to build processors that use the same architecture as Intel's
                    processors. Why do they do that? Wouldn't they make more money if people had to buy from Intel? The
                    reason is that computer manufacturers, such as Dell, Apple, and Lenovo, won't build their systems
                    around an architecture that is only available from one company. They're not worried that Intel will
                    go out of business; the worry is that there may be a larger-than-expected demand for a particular
                    processor, and Intel may not be able to fill orders on time. But if that processor is also available
                    from other companies such as AMD and Cyrix, then a delay at Intel won't turn into a delay at Dell.
                    Those other chip manufacturers may not use the same circuitry as the Intel version, as long as they
                    behave the same at the architecture level.</p>
            </div>
        </div>
        <div class="takeItFurther">
            <ol type="A">
                <li>
                    Learning enough about the Analytical Engine to be able to write even a <em>simple</em> program for
                    it is quite a large undertaking. Don't try it until after the AP exam, but if you are interested,
                    there are extensive online resources available here:
                    <ul>
                        <li><a href="http://www.fourmilab.ch/babbage/contents.html" target="_blank">The Analytical
                                Engine Table of Contents</a></li>
                        <li><a href="http://www.fourmilab.ch/babbage/emulator.html" target="_blank">Web Analytical
                                Engine Emulator</a></li>
                    </ul>
                </li>
            </ol>
        </div>
    </div>
    <div class="full-bottom-bar" style="background-position: 20px 3px;">
        <div class="bottom-nav btn-group"> <a class="btn btn-default backbutton arrow" style="min-width: 90px;"
                href="H6L1P5.html">Terug</a> <a class="btn btn-default forwardbutton arrow" style="min-width:90px;"
                href="H6L1P7.html">Volgende</a> </div>
    </div>

</body>

</html>