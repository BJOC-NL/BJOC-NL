<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" href="../../BJOC-NL-logo.png" type="image/png">
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="../../js+css/llab/loader.js"></script>
    <script type="text/javascript" src="../../js+css/gifffer.min.js"></script>
    <script type="text/javascript">
        window.onload = function () {
            Gifffer();
            Inhoudsopgave();
        }
    </script>
    <link rel="stylesheet" type="text/css" href="../../js+css/css/bjc-gifffer.css">
    <title>Hoofdstuk 5 Les 4: Oplosbare en Onbeslisbare Problemen, Pagina 2</title>
</head>

<body>
    <h2>Een Onbeslisbaar Probleem</h2>
    <div class="learn">
        <p><strong>Op deze pagina,</strong> ga je een probleem bekijken dat geen antwoord <em>kan</em> hebben.</p>
    </div>
    <p>Op dit punt in de cursus heb je de frustratie ervaren van het debuggen van een programma. Het zou geweldig zijn
        als er een algemeen foutopsporingsprogramma was dat code kon lezen en daarna bepalen of er bugs in zitten.
        Helaas kunnen we een bewijs uit het ongerijmde gebruiken (zoals Alex, Bo en Yasmine op de vorige pagina deden)
        om te bewijzen dat dit niet kan.
    </p>
    <p>Eerst gaan we ervan uit dat het mogelijk is om een functie te schrijven die bepaalt of er <em> oneindige lussen
        </em> in een programma zijn (situaties waarin een functie voor altijd wordt uitgevoerd zonder een waarde te
        rapporteren). Vervolgens zullen we die functie gebruiken in een programma dat speciaal is ontworpen om een
        tegenstrijdigheid te creëren om te bewijzen dat de veronderstelling onjuist is&mdash;
        <strong> er kan geen programma voor algemene foutopsporing bestaan </strong>. "Heeft dit programma bugs" is een
        <em> onbeslisbaar probleem </em>; er kan nooit een algoritme worden geconstrueerd dat het voor elk programma
        altijd correct oplost. </p>

    <div class="vocabFullWidth">
        <p>Een <strong>oneindige lus </strong> is een rij computer instructie dat zichzelf voor altijd blijft herhalen.
        </p>
        <p>Een <strong>onoplosbaar probleem</strong> is een probleem waarvoor geen enkel algoritme geschreven kan worden
            om de oplossing te vinden.
        </p>
        <p>Een <strong>onbeslisbaar probleem</strong>is er een waarvoor geen algoritme kan worden geschreven dat altijd
            een juiste <em> waar / niet waar beslissing </em> geeft voor elke invoerwaarde. Onbeslisbare problemen zijn
            een subcategorie van onoplosbare problemen dat alleen problemen bevat die een ja / nee-antwoord zouden
            moeten hebben (zoals: bevat mijn code een bug?). </p>
    </div>
    <h3>Aanneem dat een <code>Stopt?</code> Functie Bestaat</h3>
    <h4><strong>De Aanname Maken</strong></h4>
    <p>
        <div class="sidenote">
            We kunnen de code in <code> stopt? </code> niet weergeven; we bewijzen dat het helemaal niet kan worden
            geschreven, ongeacht hoe het geimplementeerd wordt.
        </div>
        Ten eerste <em> nemen we aan </em> dat er een functie bestaat met de naam <code> stopt? </code> die bepaalt of
        een bepaalde rapporteur een waarde in een eindige hoeveelheid tijd rapporteert. (Als dat zo is, zeggen we dat de
        rappoorteur <em> stopt. </em>) Er zijn twee ingangen nodig: een
        functie en een invoerwaarde voor die functie. Het rapporteert <code> waar </code> als de functie een waarde zou
        rapporteren wanneer die invoer wordt gegeven; het rapporteert <code> niet waar </code> als de functie voor
        altijd zou worden uitgevoerd (in een oneindige lus).
        <br /> <img class="indent" src="/bjc-r/img/5-algorithms/halts.png" alt="halts? (function) (input)" />
    </p>
    <p>Dhe function <code>rond af</code> bijvoorbeeld wordt niet voor altijd uitgevoerd met de invoer <var>7.5</var>;
        het zal 8 rapporteren.
    </p>
    <div class="sidenote"> De grijze ring om de invoerfunctie heen betekent dat de <code>stopt?</code> de invoerfunctie
        als data ziet in plaats van het uit te voeren. </div>
    <p class="indent">
        <img class="inline" src="/bjc-r/img/5-algorithms/halts-reporting.png"
            alt="halts?(round())(7.5) reporting true" /> omdat <img class="inline"
            src="/bjc-r/img/5-algorithms/round(7-5).png" alt="round (7.5)" /> een waarde rapporteert.</p>
    <p>Stel je anderzijds voor dat we een functie hebben die in een oneindige lus komt te zitten met de invoer
        <var>foo</var>; die zal nooit iets rapporteren (nooit stoppen).
    </p>
    <p class="indent"><img class="inline" src="/bjc-r/img/5-algorithms/halts-reporting-false.png"
            alt="halts?(program with an infinite loop ())(foo) reporting false" /> omdat <img class="inline"
            src="/bjc-r/img/5-algorithms/program-with-loop(foo).png" alt="program with an infinite loop (foo)" />
        oneindig zich herhaalt.
    </p>
    <h4><strong>Het Plan voor het Bewijs Bekijken the Plan for the Proof</strong></h4>
    <p>We zullen bewijs uit het ongerijmde gebruiken om te laten zien dat de volgende vraag <em>niet</em> beantwoord kan
        worden <em>in het algemeen</em>:</p>

    <p class="center"><strong> Zal een bepaald computerprogramma, met een bepaalde invoer, een resultaat rapporteren in
            een eindige hoeveelheid tijd?
        </strong></p>
    <div class="endnote">
        <p>Het "computerprogramma" is de eerste invoer voor <code>stopt?</code>.
            De 'gegeven invoer' is de tweede invoer. Wat <code>stopt</code> rapporteert is of <code>waar</code> of
            <code>niet waar</code>: het computerprogramma zal stoppen of het zal niet stoppen.
        </p>
        <p>Merk op dat <code>stopt?</code> zelf altijd een resultaat moet rapporteren, zelfs als het programma dat het
            test dat niet doet. Dit is zo omdat we <em>aannemen</em> (waarvan we gaan laten zien dat het niet klopt) dat
            <code>stopt?</code> altijd werkt, dat het altijd een antwoord rapporteert. itself must always report a
            result, even if the program it's testing doesn't.
        </p>
    </div>
    <p>We <em>kunnen</em> deze vraag beantwoorden voor <em>specifieke</em> functies, maar we willen bepalen of we een
        <em>algemene</em> test kunnen amken die ons vertelt of een bepaalde functie een waarde rapporteert voor een
        specifieke invoer.
    </p>
    <div class="endnote"> <a href="#hint-general" data-toggle="collapse">Wat betekent het dat we de vraag kunnen
            beantwoorden voor <em>specifieke</em> functies?</a>
        <div id="hint-general" class="collapse">
            <p> Het deel "in het algemeen" is belangrlijk. Natuurlijk kunnen we de vraag beantwoorden voor bepaalde
                programma's. Deze stopt voor elke invoer:
                <br /> <img class="indent" src="/bjc-r/img/5-algorithms/three-fn.png" alt="three(x): report (3)" /> </p>
            <p> Deze stopt <em>nooit</em> voor elke invoer:<br /> <img class="indent"
                    src="/bjc-r/img/5-algorithms/loop-fn.png" width="158" alt="loop(x): forever (wait 1 secs)" /> </p>
            <p> Deze stopt <em>soms</em>&mdash;voor elke invoer behalve 87:<br /> <img class="indent"
                    src="/bjc-r/img/5-algorithms/weird-fn.png" width="158"
                    alt="weird(x): if (x = 87) (forever (wait 1 secs)) else (report (3))" /> </p>
            <p>Herinner je dat de vraag is of we een test kunnen maken die ons zegt of <em>elke</em> functie een waarde
                rapporteert voor <em>elke</em> invoer.
            </p>
        </div>
    </div>
    <div class="forYouToDo" id="first">
        <ol>
            <li> <img class="inline" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Talk with Your Partner" />
                <ol>
                    <li>Beschrijf het proces van een bewijs uit het ongerijmde.</li>
                    <li>Beschrijf wat de <code>stopt?</code>functie doet.</li>
                    <li>Beschrijf hoe je de <code>stopt?</code>functie in dit bewijs gaat gebruiken.
                    </li>
                </ol>
            </li>
        </ol>
    </div>
    <h3>Laten zien hoe dit een Tegenstrijdigheid Creërt</h3>
    <h4><strong>Een Programma maken waarvoor <code>stopt?</code> Niet Werkt</strong></h4>
    <p> Om te bewijzen dat een dergelijke functie niet kan bestaan, moeten we een tegenstrijdigheid creëren. We moeten
        aantonen dat er ten minste één functie en één invoer voor die functie moet zijn waarvoor <code> stopt? </code>
        niet werkt zoals we dachten dat het werkt. Dus we kunnen een blok, <code> tester </code> maken, specifiek om
        <code> stopt? </code> te breken: <br />
        <div class="sidenoteBig"> Just like the <code>#</code> and <code>⋮</code> symbols for inputs declared to be
            <em>numbers</em> or <em>lists</em>, the <code>&lambda;</code> is not part of the input's name but is a
            <strong>type hint</strong> that was created when selecting the <em>reporter</em> input type:<br /> <img
                class="indent" src="/bjc-r/img/5-algorithms/input-type-reporter.png"
                alt="selecting the Reporter input type" /><br /> Recall that selecting an input type changes the
            appearance of the input slot so that it indicates what kind of input is expected. The input slot for
            <code>tester</code> will have a rounded gray ring to indicate that the input should be a reporter: <img
                class="inline nopadtb" src="/bjc-r/img/5-algorithms/tester().png" alt="tester ()" /> </div> <img
            class="indent" src="/bjc-r/img/5-algorithms/tester-halting.png"
            alt="tester(reporter){if(halts?(reporter)(reporter){forever{}}else{report(It doesn't matter what value is reported.)}}">
    </p>
    <p>The <code>forever</code> block in this script creates an infinite loop. If the <code>tester</code> code ends up
        in this part of the <code>if</code> statement, it will never report anything. So whether <code>tester</code>
        <em>itself</em> will halt depends on the output of the <code>halts?</code> predicate in the <code>if</code>
        statement inside it.</p>
    <p>The expression <img class="inline" src="/bjc-r/img/5-algorithms/halts-reporter-reporter.png"
            alt="halts? (reporter) (reporter)" /> asks what will happen if we call the inputted function
        (<var>reporter</var>) with <em>itself</em> as its own input. This is similar to when Betsy made a statement
        about the statement she was making, when she said, "The statement I'm making <em>right now</em> is false."</p>
    <div class="endnote"> <img class="inline" src="/bjc-r/img/icons/tough-stuff-mini.png" alt="Tough Stuff" /> This
        <em>is</em> challenging. Stick with it! We are <em>creating a contradiction</em> to prove that the
        <code>halts?</code> function called inside <code>tester</code> can't exist. </div>
    <h4><strong>Using Self-Reference to Lead to Contradiction</strong></h4>
    <p> To make the situation <em>exactly</em> like what Betsy said ("The statement I'm making <em>right now </em>is
        false."), we'll call <code>tester</code> on <em>itself</em>:<br /> <img class="indent"
            src="/bjc-r/img/5-algorithms/testertester.png" alt="tester(tester())" /><br /> Now, the <code>if</code>
        statement inside the <code>tester</code> block will ask if <code>tester</code> will halt (not run forever) if
        it's called with <code>tester</code> as its input. The predicate in the <code>if</code> statement will become
        <code>halts? (tester) (tester)</code>.<br />
        <img src="/bjc-r/img/5-algorithms/tt-t-htt.png"
            alt="tester(tester) -&gt; reporter input in tester definition -&gt; halts? (tester) (tester)">
    </p>
    <p>So, just as in the examples above,</p>
    <p class="indent"><img class="inline" src="/bjc-r/img/5-algorithms/halts-tester-tester-reporting-true.png"
            alt="halts (tester) (tester) reporting true" /> would mean that <img class="inline"
            src="/bjc-r/img/5-algorithms/testertester.png" alt="tester(tester())" /> returns a value.</p>
    <p class="indent"><img class="inline" src="/bjc-r/img/5-algorithms/halts-tester-tester-reporting-false.png"
            alt="halts (tester) (tester) reporting false" /> would mean that <img class="inline"
            src="/bjc-r/img/5-algorithms/testertester.png" alt="tester(tester())" /> loops infinitely.</p>
    <h4><strong>Understanding the Contradiction</strong></h4>
    <p> When we call <img class="inline" src="/bjc-r/img/5-algorithms/testertester.png" alt="tester(tester())" />, we
        run into the contradiction. To see how, look back at the <code>tester</code> definition:<br /> <img
            class="indent" src="/bjc-r/img/5-algorithms/tester-halting.png"
            alt="tester(reporter){if(halts?(reporter)(reporter){forever{}}else{report(true)}}"> </p>
    <p> Showing that <strong>the result has to be wrong</strong> involves a <em>case analysis</em> like the ones used to
        solve the logic puzzles on page 1. Consider the two possible cases: <ol>
            <li>If <img class="inline" src="/bjc-r/img/5-algorithms/halts-tester-tester-reporting-true.png"
                    alt="halts (tester) (tester) reports true" /> then <code>tester</code> will take the first branch of
                the <code>if</code>, and so it will loop forever. That means <img class="inline"
                    src="/bjc-r/img/5-algorithms/testertester.png" alt="tester(tester())" /> <em>won't</em> halt, and so
                <code>halts?</code> gave the wrong answer. </li>
            <li>If <img class="inline" src="/bjc-r/img/5-algorithms/halts-tester-tester-reporting-false.png"
                    alt="halts (tester) (tester) reports false" /> then <code>tester</code> will take the
                <code>else</code> branch and report "It doesn't matter what value is reported." That means <img
                    class="inline" src="/bjc-r/img/5-algorithms/testertester.png" alt="tester(tester())" />
                <em>will</em> halt, and so <code>halts?</code> is wrong again.</li>
        </ol>
    </p>
    <div class="endnote">It doesn't matter <em>what</em> value <code>tester</code> reports, just that it reports
        <em>some</em> value, but it <em>does</em> matter what value <code>halts?</code> reports.</div>
    <div class="takeNote">
        <p>No matter what <code>halts?</code> reports, it will always disagree with itself in a program like this.
            <strong>This contradiction (this logical impossibility) means that the assumption that it's possible write
                <code>halts?</code> has to be wrong</strong>. This isn't just a claim about what will happen in
            Snap<em>!</em>. The language you use to explore a computational problem can impact the clarity or
            readability of your code but not whether a solution to a problem exists. Even with advances in quantum
            computing, we will never be able to create a general-purpose debugging program. This famous example is known
            as the <em>halting problem,</em> and the fact that the halting problem is not decidable is the <em>Halting
                Theorem.</em></p>
    </div>
    <div class="forYouToDo">
        <ol start="2">
            <li> <img class="inline" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Talk with Your Partner" />
                Go over this whole proof again together. Make sure both you and your partner understand: <ol>
                    <li>Everything from exercise 1 about proof by contradiction, what <code>halts?</code> does, and how
                        <code>halts?</code> is going to be used in the proof</li>
                    <li>The basics of how the <code>tester</code> function behaves (for <em>any</em> inputted function)
                    </li>
                    <li>How calling <img class="inline" src="/bjc-r/img/5-algorithms/testertester.png"
                            alt="tester(tester())" /> leads to a contradiction</li>
                    <li>What that contradiction means in the proof</li>
                    <li>Whether the Halting problem is an unsolvable problem, an undecidable problem, or both; and
                        <em>why</em></li>
                </ol>
            </li>
            <li>Write a paragraph explaining the difference between an problem that <em>can't</em> be solved (such as
                the halting problem) and a problem that takes unreasonable time.</li>
        </ol>
    </div>
    <div class="endnote">
        <h4><strong>Who first proved the Halting Theorem?</strong></h4>
        <p>Alan Turing (1912-1954) was one of the founders of computer science. He is known for two achievements. First,
            he made a massive contribution to winning World War II by inventing a mathematical theory and corresponding
            computer hardware to break the encoded messages generated by the German Enigma machine. Second, together
            with his colleague Alonzo Church, Turing was a founder of <em>theoretical computer science</em>: proving how
            computers <em>must</em> work regardless of future technology. Though his work on the Halting Problem, he
            proved that <em>there are computations that can never be done</em>, no matter how big and fast computers
            get.</p>
        <p>When Turing did this work, there were no programmable computers; people had to rewire physical machines to
            solve each new problem. With powerful programming languages (such as Snap<em>!</em>), we can see and
            understand the essence of Turing's proof much more easily because we can use functions as inputs to other
            functions, as you've seen with <code>map</code>, <code>keep</code>, and <code>combine</code>. This proof was
            even harder for Turing because he had to invent the idea of a computer program that can itself be
            represented as data inside the computer.</p>
    </div>
    </div>
    <div class="full-bottom-bar" style="background-position: 20px 3px;">
        <div class="bottom-nav btn-group"> <a class="btn btn-default backbutton arrow" style="min-width: 90px;"
                href="H5L4P1.html">Terug</a> <a class="btn btn-default forwardbutton arrow" style="min-width:90px;"
                href="H5L5P1.html">Volgende</a> </div>
    </div>
</body>

</html>